---
title: "Preprocessing Notebook"
output: html_document
---

```{r setup, include=FALSE}
# Install and load required packages
# install.packages("tidyverse")
# install.packages("lubridate")
# install.packages("config")
# install.packages("repr")
library(tidyverse)
library(lubridate)
library(config)
library(digest)
library(glue)
library(repr)
options(warn=-1)
```


```{r}
# Set options for data frame display
options(tibble.width = Inf)
options(tibble.print_max = 50)
```

# Functions

```{r}
convert_to_snake_case <- function(col_name) {
  # Remove '__c' from the column names
  col_name <- gsub('__c', '', col_name)
  
  # Replace periods with underscores
  col_name <- gsub('\\.', '_', col_name)
  
  # Convert camel case to snake case
  # Handle the case where a lowercase letter or digit is followed by an uppercase letter
  col_name <- gsub('([a-z0-9])([A-Z])', '\\1_\\2', col_name)
  
  # Convert the entire string to lowercase
  col_name <- tolower(col_name)
  
  # Replace multiple underscores with a single underscore
  col_name <- gsub('_+', '_', col_name)
  
  return(col_name)
}
```

```{r}
# Define a function to convert entries to datetime
convert_to_datetime <- function(entry) {
  # Convert a given entry into a datetime object using R's as.POSIXct function.
  # Args:
  #   entry (character): The entry to convert to datetime.
  # Returns:
  #   POSIXct: Returns a POSIXct object if conversion is successful, otherwise NA.
  
  tryCatch({
    # Try to parse as a full date
    as.POSIXct(entry, format = "%Y-%m-%d %H:%M:%S", tz = "UTC")
  }, error = function(e) {
    # Check if it's a four-digit number (likely representing a year)
    if (grepl("^\\d{4}$", entry)) {
      as.POSIXct(paste0(entry, "-01-01"), format = "%Y-%m-%d", tz = "UTC")
    } else {
      # If it's neither a full date nor a valid year, return NA or handle as needed
      NA
    }
  })
}
```

```{r}
# Function to check if the given value is a valid Roman numeral
is_roman_numeral <- function(value) {
  # Define a regular expression to match Roman numerals
  roman_pattern <- "^M{0,3}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$"
  
  # Check if the value matches the Roman numeral pattern
  return(grepl(roman_pattern, value))
}

# Function to check if the given value has a digit
has_digit <- function(value) {
  return(grepl("\\d", as.character(value)))
}

# Function to check if the given value is a Roman numeral or contains a digit
roman_or_numeral <- function(value) {
  if (is_roman_numeral(value) || has_digit(value)) {
    return(TRUE)
  } else {
    return(FALSE)
  }
}
```


```{r}
# Function to find elements in lst1 that are not in lst2
intersection_out <- function(lst1, lst2) {
  lst3 <- lst1[!(lst1 %in% lst2)]
  return(lst3)
}

# Function to find elements in lst1 that are also in lst2
intersection_in <- function(lst1, lst2) {
  lst3 <- lst1[lst1 %in% lst2]
  return(lst3)
}
```


```{r}
# Function to check if a given string `cell` meets specific inclusion and exclusion criteria
# 
# Args:
#   cell (character): The string to check.
#   included_and (character vector, optional): List of keywords; cell must include all of these (case insensitive).
#   included_or (character vector, optional): List of keywords; cell must include at least one of these (case insensitive).
#   excluded_and (character vector, optional): List of keywords; cell must not include any of these (case insensitive).
#   excluded_or (character vector, optional): List of keywords; cell must not include at least one of these (case insensitive).
# 
# Returns:
#   logical: TRUE if `cell` meets all specified criteria, FALSE otherwise.
 
generalized_contains <- function(cell, included_and=NULL, included_or=NULL, excluded_and=NULL, excluded_or=NULL) {
  if (!is.character(cell)) {
    return(FALSE)  # Return FALSE if `cell` is not a string
  }
  
  cell_lower <- tolower(cell)  # Convert `cell` to lowercase
  
  # Check included_and condition
  if (!is.null(included_and)) {
    if (!all(sapply(included_and, function(keyword) grepl(keyword, cell_lower)))) {
      return(FALSE)  # Return FALSE if `cell_lower` does not contain all keywords in `included_and`
    }
  }
  
  # Check included_or condition
  if (!is.null(included_or)) {
    if (!any(sapply(included_or, function(keyword) grepl(keyword, cell_lower)))) {
      return(FALSE)  # Return FALSE if `cell_lower` does not contain any keyword in `included_or`
    }
  }
  
  # Check excluded_and condition
  if (!is.null(excluded_and)) {
    if (any(sapply(excluded_and, function(keyword) grepl(keyword, cell_lower)))) {
      return(FALSE)  # Return FALSE if `cell_lower` contains any keyword in `excluded_and`
    }
  }
  
  # Check excluded_or condition
  if (!is.null(excluded_or)) {
    if (any(sapply(excluded_or, function(keyword) grepl(keyword, cell_lower)))) {
      return(FALSE)  # Return FALSE if `cell_lower` contains any keyword in `excluded_or`
    }
  }
  
  return(TRUE)  # Return TRUE if all conditions are satisfied
}

### Example usage
# cell <- "This board member is a past chairperson."
# included_and <- c('board', 'member')
# included_or <- c('past', 'former')
# excluded_and <- NULL
# excluded_or <- NULL
# generalized_contains(cell, included_and, included_or, excluded_and, excluded_or)
# 
# cell <- "This board member is a past chairperson."
# included_and <- c('board', 'member')
# included_or <- NULL
# excluded_and <- NULL
# excluded_or <- c('past', 'former')
# generalized_contains(cell, included_and, included_or, excluded_and, excluded_or)
# 
# cell <- "prospect_manager_2nd"
# included_and <- NULL
# included_or <- c('prospect_manager', 'solicitor')
# excluded_and <- NULL
# excluded_or <- c("2")
# generalized_contains(cell, included_and, included_or, excluded_and, excluded_or)
```

```{r}
# Function to pick a value from either col1 or col2 of a given row based on priority rules
# 
# Args:
#   row (data.frame row): The row (data.frame row) from which to pick values.
#   col1 (character): The name of the first column to consider.
#   col2 (character): The name of the second column to consider.
# 
# Returns:
#   object: The value from col1 or col2 based on the priority rules:
#       - If both values are NA, returns NA.
#       - If only one value is NA, returns the non-NA value.
#       - If both values are equal and not NA, returns that value.
#       - Otherwise, returns NA and prints the conflicting values (for debugging).

pick_col <- function(row, col1, col2) {
  x <- row[[col1]]
  y <- row[[col2]]
  
  if (is.na(x) && is.na(y)) {
    return(NA)  # Return NA if both values are NA
  } else if (is.na(x)) {
    return(y)   # Return y if x is NA
  } else if (is.na(y)) {
    return(x)   # Return x if y is NA
  } else if (x == y) {
    return(x)   # Return x (or y, since x == y) if both are equal and not NA
  } else {
    cat(paste(x, y, sep = " "), "\n")  # Print conflicting values for debugging
    return(NA)  # Return NA for conflicting values
  }
}
```

```{r}
# Function to rename the '_merge' column in the merged dataframe to a source indicator column,
# and map its values to more descriptive labels based on merge sources.
# 
# Args:
#   merged_df (data.frame): The merged dataframe resulting from a merge operation.
#   left_source (character): The label for the left dataframe source.
#   right_source (character): The label for the right dataframe source.
# 
# Returns:
#   data.frame: The merged dataframe `merged_df` with the '_merge' column renamed to indicate source,
#               and its values mapped to descriptive labels based on merge sources.

df_merge_source <- function(merged_df, left_source, right_source) {
  # Rename the '_merge' column to 'source'
  new_col <- "df_source"
  while (new_col %in% names(merged_df)) {
    i <- 1
    new_col <- paste0("df_source_", i)
    i <- i + 1
  }
  
  names(merged_df)[names(merged_df) == "_merge"] <- new_col
  
  # Map the source column to more descriptive labels
  source_mapping <- list(
    'left_only' = left_source,
    'right_only' = right_source,
    'both' = paste0(left_source, "/", right_source)
  )
  
  merged_df[[new_col]] <- factor(merged_df[[new_col]], levels = names(source_mapping))
  merged_df[[new_col]] <- factor(merged_df[[new_col]], labels = source_mapping)
  
  return(merged_df)
}
```

```{r}
# Function to remove dollar signs ('$') and commas (',') from a given string representation of a number
# 
# Args:
#   cell (character or any): The string or value from which to remove dollar signs and commas.
# 
# Returns:
#   character or any: The modified string with dollar signs and commas removed, or the original value if not a string.

remove_dollar_sign_and_comma <- function(cell) {
  if (is.character(cell)) {
    cell <- gsub("\\$|,", "", cell)  # Remove dollar signs ('$') and commas (',')
  }
  return(cell)
}
```

```{r}
# Function to save a data frame to a CSV file with a specified file name format and path
# 
# Args:
#   df (data.frame): The data frame to save.
#   file_prefix (character, optional): The prefix for the CSV file name. Default is "constituents_cleaned".
#   version (character, optional): The version identifier for the CSV file name. Default is "v1".
# 
# Returns:
#   NULL

save_file <- function(df, file_prefix = "constituents_cleaned", version = "v1") {
  # Check if "Unique Donor ID" column exists and drop rows with NA values in that column
  if ("Unique Donor ID" %in% names(df)) {
    df <- df[!is.na(df[["Unique Donor ID"]]), ]
  }
  
  # Construct file name based on file_prefix and version
  file_name <- paste0(file_prefix, "_", version, ".csv")
  
  # Define file path components (replace with actual paths as needed)
  file_path <- "/path/to/your/file"  # Replace with actual file path
  clients <- "your_clients_folder"   # Replace with actual clients folder
  subdir <- "your_subdirectory"      # Replace with actual subdirectory
  
  # Create directory structure if it doesn't exist
  dir.create(file.path(file_path, "Cleaning"), showWarnings = FALSE, recursive = TRUE)
  
  # Save data frame to CSV file
  write.csv(df, file.path(file_path, "Cleaning", file_name), row.names = FALSE)
}
```

# Variables

```{r}
file_path <- "C:\\Users\\Rmittal\\CCS\\Internal - Analytics - Shared Drive\\1. Shared Drive\\Clients"
clients <- "National Multiple Sclerosis Society"
```


# Gifts Data

```{r}
subdir <- "Raw Client Data/Section 2" 
file_name <- "Section 2  CCS May 2024-2024-05-22-20-12-55.csv"
file <- file.path(file_path, clients, subdir, file_name)
dfg_1 <- read.csv(file, encoding="ISO-8859-1")

dfg_1 <- dfg_1[dfg_1$Stage == "Closed Won", ]
dfg_1$source <- file_name
dfg_1$Close.Date <- as.Date(dfg_1$Close.Date, format="%m/%d/%Y")

file_name <- "Section 2  CCS May 2024 Pt. 2 GAU Ref-2024-05-30-03-00-07.csv"
file <- file.path(file_path, clients, subdir, file_name)
dfg_2 <- read.csv(file, encoding="ISO-8859-1")
dfg_2$source <- file_name
dfg_2 <- dfg_2 %>% select(-Campaign)

rename_columns <- c("Opportunity: Opportunity ID" = "Opportunity ID", 
                    "Opportunity: Opportunity Record Type" = "Opportunity Record Type")

dfg_2.rename(columns=rename_columns, inplace=True)

dfg_2 <- dfg_2 %>% rename(!!!rename_columns)

dfg_2$Close.Date <- substr(dfg_2$Opportunity.Opportunity.Name, nchar(dfg_2$Opportunity.Opportunity.Name) - 9, nchar(dfg_2$Opportunity.Opportunity.Name))
dfg_2$Close.Date <- as.Date(dfg_2$Close.Date, format="%Y-%m-%d")
```

```{r}
dfg_2$Close.Date[dfg_2$Opportunity.ID == "006f400000TcYLhAAN" & dfg_2$GAU.Allocation.ID == "a0b5G00000RlpR6QAJ"] <- as.Date("2021-10-01")
dfg_2$Close.Date[dfg_2$Opportunity.ID == "0065G00000XKQIYQA5" & dfg_2$GAU.Allocation.ID == "a0b5G00000TVtxWQAT"] <- as.Date("2021-10-01")
dfg_2$Close.Date[dfg_2$Opportunity.ID == "0065G00000bXpneQAC" & dfg_2$GAU.Allocation.ID == "a0b5G00000VMeCOQA1"] <- as.Date("2020-09-30")
dfg_2$Close.Date[dfg_2$Opportunity.ID == "006f400000TqcZMAAZ" & dfg_2$GAU.Allocation.ID == "a0bPd000000PsEvIAK"] <- as.Date("2023-09-30")
dfg_2$Close.Date <- as.Date(dfg_2$Close.Date, format="%Y-%m-%d")
```

## Concatenate dfg_1 and dfg_2

```{r}
dfg <- bind_rows(dfg_1, dfg_2)
dfg$Close.Date <- as.Date(dfg$Close.Date, format="%Y-%m-%d")
dfg$Amount <- as.numeric(gsub(",", "", dfg$Amount))
```

```{r}
dfg <- dfg %>% rename(gift_amount = Amount,
                      gift_type = Opportunity.Record.Type,
                      gift_date = Close.Date,
                      gift_id = Opportunity.ID)
```

```{r}
save_file(dfg, file_prefix = "gifts_cleaned", version="v1")
```

## Five Year Giving

```{r}
dfg <- dfg %>% rename(constituent_id = Primary.Contact.ID)
dfg_subset <- dfg %>% filter(Close.Date > as.Date("2019-10-01"))
dfg_subset <- dfg_subset %>% drop_na(Amount)
dfg_fyg <- dfg_subset %>% group_by(Opportunity.ID) %>% 
  summarise(five_year_giving = sum(Amount, na.rm = TRUE)) %>% 
  ungroup()
```

# Combine Files

```{r}
subdir <- "Raw Client Data\\Section 3" 
shared_drive <- file.path(file_path, clients, subdir)
file_list <- list.files(shared_drive, pattern = "section", ignore.case = TRUE)
#file_names = ["Section 3-A.csv"]

for (i in seq_along(file_list)) {
  file <- file_list[i]
  full_path <- file.path(shared_drive, file)
  assign(paste0("df_", i), read.csv(full_path, encoding="ISO-8859-1"))
}
```

```{r}
run <- FALSE
if (run) {
  df_cd <- data.frame()
  for (i in 1:11) {
    df_cd <- bind_rows(df_cd, get(paste0("df_", i)))
  }
  saveRDS(df_cd, "df_cd_combined.RDS")
}
```

```{r}
run <- FALSE
if (run) {
  df_cd <- read.csv("nmss_constit.csv")
}
```

# Convert the column names into snake case

```{r}
# Apply the convert_to_snake_case function to all column names
df_cd <- df_cd %>% rename_all(~ convert_to_snake_case(.))
```

# Check for overall duplicates

```{r}
run <- FALSE
if (run) {
  df_cd <- df_cd %>% distinct()
}

## 9038462
## 9038462)
```

# Renaming

```{r}
rename_columns <- c("x18_char_contact_id" = "constituent_id",
                    "account_name" = "head_of_household",
                    "account_id" = "household_id",
                    "account_record_type_name" = "key_indicator")

df_cd <- df_cd %>% rename(!!!rename_columns)

#Board_Member_Check__c', 'National_Board_Member__c' --> current_trustee_indicator, past_trustee_indicator 
#is_assigned, assigned_manager --> "Account.Owner.Name", "Owner.Name" \
                                  # (list of strings: "migrations user, inactive, integration*")
#Board_Member_Check__c --> we're also checking the file "persona" (csv)
#df_cd.columns.to_list())
```

```{r}
df_cd <- df_cd %>% rename(!!!rename_columns)
```

# Constituent_id

```{r}
n_distinct(df_cd$constituent_id)
```

# Formatting

##### Remove dollar sign and comma

```{r}
amount_columns <- grep("amount", names(df_cd), value = TRUE, ignore.case = TRUE)
df_cd[amount_columns] <- df_cd[amount_columns] %>% 
  mutate_all(~ as.numeric(remove_dollar_sign_and_comma(.)))
```

# key_indicator

```{r}
df_cd["key_indicator"].value_counts()
```

# is_individual

```{r}
df_cd <- df_cd %>% mutate(is_individual = key_indicator == "Household")
```

# is_deceased

```{r}
df_cd <- df_cd %>% mutate(is_deceased = npsp_deceased == TRUE | !is.na(deceased_date))
```

# Trustee

```{r}
df_cd <- df_cd %>% mutate(current_trustee_indicator = board_member_check == 1 | national_board_member == 1)
```

# pg_indicator

```{r}
subdir <- "Raw Client Data" 
file_name <- "Contacts with Personas.csv"

file <- file.path(file_path, clients, subdir, file_name)
df_pg <- read.csv(file, encoding="ISO-8859-1")
df_pg <- df_pg %>% rename(constituent_id = `18 Char Contact ID`)
df_pg_lawry <- df_pg %>% filter(grepl("lawry circle donor", Type, ignore.case = TRUE))

pg_constit_id <- unique(df_pg_lawry$constituent_id)
df_cd <- df_cd %>% mutate(pg_indicator = constituent_id %in% pg_constit_id)
```

# head_of_household and household_id

```{r}
get_max_index <- function(group) {
  if ("Total Lifetime Giving" %in% colnames(group)) {
    if (max(group$Total.Lifetime.Giving, na.rm = TRUE) > 0) {
      return(which.max(group$Total.Lifetime.Giving))
    }
  }
  return(1)
}

df_cdi <- df_cd %>% filter(!is_deceased & is_individual)
df_cdi <- df_cdi %>% mutate(head_of_household = TRUE)

df_cdi <- df_cdi %>% 
  drop_na(Address.1, Address.2) %>% 
  mutate_at(vars(Address.1, Address.2, City, State, Zip), ~ replace_na(., 'missing')) %>% 
  filter(apply(df_cdi, 1, function(row) roman_or_numeral(row["Address.1"]) | roman_or_numeral(row["Address.2"])))

df_cdi_multiple <- df_cdi %>% 
  group_by(Address.1, Address.2, City, State, Zip) %>% 
  filter(n() > 1) %>% 
  arrange(Address.1, Address.2, City, State, Zip)

grouped <- df_cdi_multiple %>% group_by(Address.1, Address.2, City, State, Zip)

idx_max_lifetime_giving <- grouped %>% group_map(~ get_max_index(.x)) %>% unlist()

df_cdi <- df_cdi %>% mutate(head_of_household = FALSE)
df_cdi <- df_cdi %>% 
  mutate(head_of_household = ifelse(row_number() %in% idx_max_lifetime_giving, TRUE, head_of_household))

df_cdi_multiple <- df_cdi_multiple %>% mutate(head_of_household = FALSE)
df_cdi_multiple <- df_cdi_multiple %>% 
  mutate(head_of_household = ifelse(row_number() %in% idx_max_lifetime_giving, TRUE, head_of_household))

df_cdi_multiple <- df_cdi_multiple %>% mutate(household_id = group_indices(grouped))

df_cdi <- df_cdi %>% 
  left_join(df_cdi_multiple %>% select(Unique.Donor.ID, household_id), by = "Unique.Donor.ID") %>% 
  mutate(household_id = replace_na(household_id, 0))

df_cd <- df_cd %>% 
  left_join(df_cdi %>% select(Unique.Donor.ID, head_of_household, household_id), by = "Unique.Donor.ID")
```

# is_assigned

```{r}
columns_solicitor_type <- grep("solicitor type", names(df_cd), value = TRUE, ignore.case = TRUE)
columns_solicitor_name <- grep("solicitor name", names(df_cd), value = TRUE, ignore.case = TRUE)

df_cd <- df_cd %>% mutate(is_assigned = FALSE)

for (i in seq_along(columns_solicitor_type)) {
  solicitor_type_col <- columns_solicitor_type[i]
  solicitor_name_col <- columns_solicitor_name[i]
  
  included_or <- c("solicitor", "prospect manager")
  excluded_or <- c("2")
  df_cd <- df_cd %>% mutate(is_assigned_1 = generalized_contains(!!sym(solicitor_type_col), included_or = included_or, excluded_or = excluded_or))
  
  excluded_and <- c("president", "lawrence a. selzer")
  df_cd <- df_cd %>% mutate(is_assigned_2 = generalized_contains(!!sym(solicitor_name_col), excluded_and = excluded_and))
  
  df_cd <- df_cd %>% mutate(is_assigned = is_assigned | (is_assigned_1 & is_assigned_2))
}

df_cd <- df_cd %>% select(-is_assigned_1, -is_assigned_2)
```

# assigned_manager

```{r}
conditions <- list(
  (df_cd$is_assigned == TRUE) & !is.na(df_cd$Solicitor.Name_1) & !grepl("president|lawrence a. selzer", df_cd$Solicitor.Name_1, ignore.case = TRUE),
  (df_cd$is_assigned == TRUE) & !is.na(df_cd$Solicitor.Name_2) & !grepl("president|lawrence a. selzer", df_cd$Solicitor.Name_2, ignore.case = TRUE),
  (df_cd$is_assigned == TRUE) & !is.na(df_cd$Solicitor.Name_3) & !grepl("president|lawrence a. selzer", df_cd$Solicitor.Name_3, ignore.case = TRUE),
  (df_cd$is_assigned == TRUE) & !is.na(df_cd$Solicitor.Name_4) & !grepl("president|lawrence a. selzer", df_cd$Solicitor.Name_4, ignore.case = TRUE),
  (df_cd$is_assigned == TRUE) & !is.na(df_cd$Solicitor.Name_5) & !grepl("president|lawrence a. selzer", df_cd$Solicitor.Name_5, ignore.case = TRUE),
  (df_cd$is_assigned == TRUE) & !is.na(df_cd$Solicitor.Name_6) & !grepl("president|lawrence a. selzer", df_cd$Solicitor.Name_6, ignore.case = TRUE)
)

choices <- c(
  df_cd$Solicitor.Name_1,
  df_cd$Solicitor.Name_2,
  df_cd$Solicitor.Name_3,
  df_cd$Solicitor.Name_4,
  df_cd$Solicitor.Name_5,
  df_cd$Solicitor.Name_6
)

df_cd <- df_cd %>% mutate(assigned_manager = dplyr::coalesce(!!!choices))
```

# solicit_codes

```{r}
columns_solicit_codes <- grep("solicit", names(df_cd), value = TRUE, ignore.case = TRUE)
df_cd <- df_cd %>% mutate(solicit_codes = rowSums(select(., all_of(columns_solicit_codes)), na.rm = TRUE) > 0)
df_cd$solicit_codes <- as.integer(df_cd$solicit_codes)
```

# marital_status

```{r}
columns_spouse <- grep("spouse", names(df_cd), value = TRUE, ignore.case = TRUE)
df_cd <- df_cd %>% mutate(marital_status = ifelse(rowSums(select(., all_of(columns_spouse)), na.rm = TRUE) > 0, "married", NA))
df_cd <- df_cd %>% mutate(marital_status = ifelse(!is.na(df_cd$Spouse.deceased), "widow", df_cd$marital_status))
```

# five_year_giving

```{r}
df_cd <- df_cd %>% mutate(five_year_giving = rowSums(select(., starts_with("2024 Giving Total"),
                                                            starts_with("2023 Giving Total"),
                                                            starts_with("2022 Giving Total"),
                                                            starts_with("2021 Giving Total"),
                                                            starts_with("2020 Giving Total"),
                                                            starts_with("2019 Giving Total")), na.rm = TRUE))
```

# Model Scores

```{r}
df_cd <- df_cd %>% mutate(major_donor_model_score = 0,
                          loyalty_model_score = 0,
                          n_years_giving_of_ten = NA)
```

# planned_gift_commitment

```{r}
columns_planned <- grep("planned", names(df_cd), value = TRUE, ignore.case = TRUE)
df_cd <- df_cd %>% mutate(planned_gift_commitment = rowSums(select(., all_of(columns_planned)), na.rm = TRUE) > 0)
df_cd$planned_gift_commitment <- as.integer(df_cd$planned_gift_commitment)
```

# Staff Indicator

```{r}
run <- FALSE
if (run) {
  save_file(df_cd, file_prefix = "constituents_cleaned_no_staff_indicator", version = "v2")
}
```

```{r}
subdir <- "Raw Client Data" 
file_name <- "All Staff List - for Sara Groh - 05162024.xlsx"

file <- file.path(file_path, clients, subdir, file_name)
df_staff <- readxl::read_excel(file)
df_staff <- df_staff %>% rename(npe01_home_email = `Email - Primary Home`,
                                npe01_alternate_email = `Email - Work`)
```

```{r}
head(df_staff)
```

```{r}
# Merge df_cd with df_staff based on email columns
df_cd <- df_cd %>%
  left_join(df_staff %>% select(npe01_home_email, npe01_alternate_email), 
            by = c("npe01_home_email", "npe01_alternate_email"), 
            keep = TRUE)
```

```{r}
# Create staff_indicator column
df_cd <- df_cd %>%
  mutate(staff_indicator = ifelse(`_merge` == "both", 1, 0)) %>%
  select(-`_merge`)
```

```{r}
# Check the counts of different merge results
table(df_cd$staff_indicator)
```

```{r}
# Check the counts of different values in the other_street column
table(df_cd$other_street)
```

```{r}
run <- FALSE
if (run) {
  save_file(df_cd, file_prefix = "constituents_cleaned", version = "v2")
}
```

# Mapper

```{r}
save_file(df_cd, file_prefix = "constituents_before_mapping", version = "v1")

mapping <- read.csv("./constit_mapping_nmss.csv")
column_mapping <- setNames(mapping$expected_columns, mapping$file_columns)
df_final <- df_cd %>% rename(!!!column_mapping)
df_final <- df_final %>% select(all_of(column_mapping))
save_file(df_final, file_prefix = "constituents_cleaned_mapped", version = "v1")
```

# Address

```{r}
df_cd <- df_cd %>% mutate(business_address = preferred_address_type == "Business",
                          seasonal_address = grepl("summer|winter|alternate", preferred_address_type, ignore.case = TRUE))
```

# Phone

```{r}
df_cd <- df_cd %>% mutate(home_phone = ifelse(Phone.Type == "Home", Phone.Number, NA),
                          home_phone = ifelse(is.na(home_phone) & Phone.Type_1 == "Home", Phone.Number_1, home_phone),
                          cell_phone = ifelse(Phone.Type == "Cell", Phone.Number, NA),
                          cell_phone = ifelse(is.na(cell_phone) & Phone.Type_1 == "Cell", Phone.Number_1, cell_phone))
```

# Email

```{r}
# Define conditions
conditions <- list(
  !is.na(df_cd$Email),
  !is.na(df_cd$Email_1),
  !is.na(df_cd$Email_2),
  !is.na(df_cd$Email_3)
)

# Define choices corresponding to the conditions
choices <- c(
  df_cd$Email,
  df_cd$Email_1,
  df_cd$Email_2,
  df_cd$Email_3
)

# Create the 'personal_email' column
df_cd <- df_cd %>% mutate(personal_email = coalesce(!!!choices))
```

# number_of_events_attended

```{r}
df_cd <- df_cd %>% mutate(number_of_special_events_attended = rowSums(select(., starts_with("Events")), na.rm = TRUE))
```

# total_notes

```{r}
df_cd <- df_cd %>% mutate(Total_Notes = replace_na(Total_Notes, 0),
                          `Total Notes` = replace_na(`Total Notes`, 0),
                          total_notes = Total_Notes + `Total Notes`)
```

# Mapper

## Correlation Plots with Total Lifetime Giving

```{r}
library(ggplot2)

# Drop rows with NaNs in these columns
df_cleaned <- df_cdi_multiple %>% drop_na(`Total Lifetime Giving`, `Total Actions`)

ggplot(df_cleaned, aes(x = log(`Total Lifetime Giving`), y = `Total Actions`)) +
  geom_point() +
  labs(title = "Scatter Plot of Total Lifetime Giving vs. Total Actions",
       x = "Total Lifetime Giving (log scale)",
       y = "Total Actions") +
  theme_minimal()

df_cleaned <- df_cdi_multiple %>% drop_na(`Total Lifetime Giving`, `Pledged Planned Gift`)

ggplot(df_cleaned, aes(x = log(`Total Lifetime Giving`), y = `Pledged Planned Gift`)) +
  geom_point() +
  labs(title = "Scatter Plot of Total Lifetime Giving vs. Pledged Planned Gift",
       x = "Total Lifetime Giving (log scale)",
       y = "Pledged Planned Gift") +
  theme_minimal()
```

# Preprocessing after mapping

```{r}
df_cd <- df_cd %>% mutate(class_year = str_extract(class_year, "\\d{2}"),
                          class_year = ifelse(as.numeric(class_year) > 25, paste0("19", class_year), paste0("20", class_year)),
                          class_year = as.integer(class_year))

df_cd <- df_cd %>% mutate_at(vars(ends_with("Date")), as.Date)
```

```{r}
save_file(df_cd, file_prefix = "constituents_cleaned_final", version = "v1")
```
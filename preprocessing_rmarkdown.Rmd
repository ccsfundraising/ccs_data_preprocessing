---
  title: "Preprocessing Notebook"
output: html_document
---

```{r setup, include=FALSE}
# Install and load required packages
# install.packages("tidyverse")
# install.packages("lubridate")
# install.packages("config")
# install.packages("repr")
library(tidyverse)
library(lubridate)
library(config)
library(digest)
library(glue)
library(repr)
library(janitor)
library(stringi)
library(readxl)
library(scales) #ggplot aesthetics
library(purrr) #mapping across reading excel files
library(tidymodels) #modeling metapackage
library(caret) #modeling cleanly
library(doParallel) #parallelizing some modeling
library(leaps) #stepwise regression
library(ccsfun) #ccs functions package
library(magrittr) #for the pipe operator
options(warn=-1)
```


```{r}
# Set options for data frame display
options(tibble.width = Inf)
options(tibble.print_max = 50)
```

# Functions

```{r}
convert_to_snake_case <- function(col_name) {
  # Remove '__c' from the column names
  col_name <- gsub('__c', '', col_name)
  
  # Replace periods with underscores
  col_name <- gsub('\\.', '_', col_name)
  
  # Convert camel case to snake case
  # Handle the case where a lowercase letter or digit is followed by an uppercase letter
  col_name <- gsub('([a-z0-9])([A-Z])', '\\1_\\2', col_name)
  
  # Convert the entire string to lowercase
  col_name <- tolower(col_name)
  
  # Replace multiple underscores with a single underscore
  col_name <- gsub('_+', '_', col_name)
  
  return(col_name)
}
```

```{r}
# Define a function to convert entries to datetime
convert_to_datetime <- function(entry) {
  # Convert a given entry into a datetime object using R's as.POSIXct function.
  # Args:
  #   entry (character): The entry to convert to datetime.
  # Returns:
  #   POSIXct: Returns a POSIXct object if conversion is successful, otherwise NA.
  
  tryCatch({
    # Try to parse as a full date
    as.POSIXct(entry, format = "%Y-%m-%d %H:%M:%S", tz = "UTC")
  }, error = function(e) {
    # Check if it's a four-digit number (likely representing a year)
    if (grepl("^\\d{4}$", entry)) {
      as.POSIXct(paste0(entry, "-01-01"), format = "%Y-%m-%d", tz = "UTC")
    } else {
      # If it's neither a full date nor a valid year, return NA or handle as needed
      NA
    }
  })
}
```

```{r}
# Function to check if the given value is a valid Roman numeral
is_roman_numeral <- function(value) {
  # Define a regular expression to match Roman numerals
  roman_pattern <- "^M{0,3}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$"
  
  # Check if the value matches the Roman numeral pattern
  return(grepl(roman_pattern, value))
}

# Function to check if the given value has a digit
has_digit <- function(value) {
  return(grepl("\\d", as.character(value)))
}

# Function to check if the given value is a Roman numeral or contains a digit
roman_or_numeral <- function(value) {
  if (is_roman_numeral(value) || has_digit(value)) {
    return(TRUE)
  } else {
    return(FALSE)
  }
}
```


```{r}
# Function to find elements in lst1 that are not in lst2
intersection_out <- function(lst1, lst2) {
  lst3 <- lst1[!(lst1 %in% lst2)]
  return(lst3)
}

# Function to find elements in lst1 that are also in lst2
intersection_in <- function(lst1, lst2) {
  lst3 <- lst1[lst1 %in% lst2]
  return(lst3)
}

# find the different columns in a list of dataframes that are in the same dataframe
ls_intersection<- function(x) {
  for (i in seq_along(x)) {
    print(setdiff(ls(x[[i]]),ls(x[[length(x)]])))
  }
}
```


```{r}
# Function to check if a given string `cell` meets specific inclusion and exclusion criteria
# 
# Args:
#   cell (character): The string to check.
#   included_and (character vector, optional): List of keywords; cell must include all of these (case insensitive).
#   included_or (character vector, optional): List of keywords; cell must include at least one of these (case insensitive).
#   excluded_and (character vector, optional): List of keywords; cell must not include any of these (case insensitive).
#   excluded_or (character vector, optional): List of keywords; cell must not include at least one of these (case insensitive).
# 
# Returns:
#   logical: TRUE if `cell` meets all specified criteria, FALSE otherwise.

generalized_contains <- function(cell, included_and=NULL, included_or=NULL, excluded_and=NULL, excluded_or=NULL) {
  if (!is.character(cell)) {
    return(FALSE)  # Return FALSE if `cell` is not a string
  }
  
  cell_lower <- tolower(cell)  # Convert `cell` to lowercase
  
  # Check included_and condition
  if (!is.null(included_and)) {
    if (!all(sapply(included_and, function(keyword) grepl(keyword, cell_lower)))) {
      return(FALSE)  # Return FALSE if `cell_lower` does not contain all keywords in `included_and`
    }
  }
  
  # Check included_or condition
  if (!is.null(included_or)) {
    if (!any(sapply(included_or, function(keyword) grepl(keyword, cell_lower)))) {
      return(FALSE)  # Return FALSE if `cell_lower` does not contain any keyword in `included_or`
    }
  }
  
  # Check excluded_and condition
  if (!is.null(excluded_and)) {
    if (any(sapply(excluded_and, function(keyword) grepl(keyword, cell_lower)))) {
      return(FALSE)  # Return FALSE if `cell_lower` contains any keyword in `excluded_and`
    }
  }
  
  # Check excluded_or condition
  if (!is.null(excluded_or)) {
    if (any(sapply(excluded_or, function(keyword) grepl(keyword, cell_lower)))) {
      return(FALSE)  # Return FALSE if `cell_lower` contains any keyword in `excluded_or`
    }
  }
  
  return(TRUE)  # Return TRUE if all conditions are satisfied
}
```

```{r}
# Function to pick a value from either col1 or col2 of a given row based on priority rules
# 
# Args:
#   row (data.frame row): The row (data.frame row) from which to pick values.
#   col1 (character): The name of the first column to consider.
#   col2 (character): The name of the second column to consider.
# 
# Returns:
#   object: The value from col1 or col2 based on the priority rules:
#       - If both values are NA, returns NA.
#       - If only one value is NA, returns the non-NA value.
#       - If both values are equal and not NA, returns that value.
#       - Otherwise, returns NA and prints the conflicting values (for debugging).

pick_col <- function(row, col1, col2) {
  x <- row[[col1]]
  y <- row[[col2]]
  
  if (is.na(x) && is.na(y)) {
    return(NA)  # Return NA if both values are NA
  } else if (is.na(x)) {
    return(y)   # Return y if x is NA
  } else if (is.na(y)) {
    return(x)   # Return x if y is NA
  } else if (x == y) {
    return(x)   # Return x (or y, since x == y) if both are equal and not NA
  } else {
    cat(paste(x, y, sep = " "), "\n")  # Print conflicting values for debugging
    return(NA)  # Return NA for conflicting values
  }
}
```

```{r}
# Function to rename the '_merge' column in the merged dataframe to a source indicator column,
# and map its values to more descriptive labels based on merge sources.
# 
# Args:
#   merged_df (data.frame): The merged dataframe resulting from a merge operation.
#   left_source (character): The label for the left dataframe source.
#   right_source (character): The label for the right dataframe source.
# 
# Returns:
#   data.frame: The merged dataframe `merged_df` with the '_merge' column renamed to indicate source,
#               and its values mapped to descriptive labels based on merge sources.

df_merge_source <- function(merged_df, left_source, right_source) {
  # Rename the '_merge' column to 'source'
  new_col <- "df_source"
  while (new_col %in% names(merged_df)) {
    i <- 1
    new_col <- paste0("df_source_", i)
    i <- i + 1
  }
  
  names(merged_df)[names(merged_df) == "_merge"] <- new_col
  
  # Map the source column to more descriptive labels
  source_mapping <- list(
    'left_only' = left_source,
    'right_only' = right_source,
    'both' = paste0(left_source, "/", right_source)
  )
  
  merged_df[[new_col]] <- factor(merged_df[[new_col]], levels = names(source_mapping))
  merged_df[[new_col]] <- factor(merged_df[[new_col]], labels = source_mapping)
  
  return(merged_df)
}
```

```{r}
# Function to remove dollar signs ('$') and commas (',') from a given string representation of a number
# 
# Args:
#   cell (character or any): The string or value from which to remove dollar signs and commas.
# 
# Returns:
#   character or any: The modified string with dollar signs and commas removed, or the original value if not a string.

remove_dollar_sign_and_comma <- function(cell) {
  if (is.character(cell)) {
    cell <- gsub("\\$|,", "", cell)  # Remove dollar signs ('$') and commas (',')
  }
  return(cell)
}
```

```{r compare datatypes in dataframes}
#function to compare datatypes between dataframes list and seeing what is different and where

compare_datatypes <- function(listoffiles){
  ndf<- as.numeric(length(listoffiles))
  for (i in 1:(ndf-1)){
    g1<- names(listoffiles[[i]])
    g2<- names(listoffiles[[ndf]])
    
    common_names <- intersect(g1,g2)
    
    # Compare data types for common columns
    for (col_name in common_names) {
      df1_type <- class(listoffiles[[i]][[col_name]])
      df2_type <- class(listoffiles[[ndf]][[col_name]])
      if (df1_type != df2_type) {
        result_df <- data.frame(Column = col_name, df1 = df1_type, df2 = df2_type,name_of_df_1 = names(listoffiles[i]))
      }
      else{return(print("No differences in data types"))}
    }
  }
}
```

```{r}
# Function to save a data frame to a CSV file with a specified file name format and path
# 
# Args:
#   df (data.frame): The data frame to save.
#   file_prefix (character, optional): The prefix for the CSV file name. Default is "constituents_cleaned".
#   version (character, optional): The version identifier for the CSV file name. Default is "v1".
# 
# Returns:
#   NULL

save_file <- function(df, file_prefix = NA, version = "v1") {
  # Check if "Unique Donor ID" column exists and drop rows with NA values in that column
  #  if ("Unique Donor ID" %in% names(df)) {
  #   df <- df[!is.na(df[["Unique Donor ID"]]), ]
  #}
  
  # Construct file name based on file_prefix and version
  file_name <- paste0(file_prefix, "_", version, ".csv")
  
  # Define file path components (replace with actual paths as needed)
  path <-paste0(Sys.getenv("USERPROFILE"),"\\CCS\\Internal - Analytics - 1. Shared Drive\\Clients")
  clients <- ""  # Replace with actual clients folder
  subdir <- "Data- Analyze & Prescribe\\ccs_data_preprocessing"
  
  file_pathway<-paste(path, clients, subdir,sep = "\\")
  
  # Create directory structure if it doesn't exist
  dir.create(file.path(file_pathway, "Cleaning"), showWarnings = FALSE, recursive = TRUE)
  
  # Save data frame to CSV file
  write.csv(df, file.path(file_pathway, "Cleaning", file_name), row.names = FALSE)
}
```

# Variables

# Variables

```{r}
file_path <- paste0(Sys.getenv("USERPROFILE"),"\\CCS\\Internal - Analytics - 1. Shared Drive\\Clients")
clients <- ""
subdir <- "Raw Client Data"

save_constit_for_dv <- "constituents_for_dv"
save_constit_before_mapping <- "constituents_before_mapping"
save_constit_after_mapping <- "constituents_preprocessed"
save_gifts_after_mapping <- "gifts_preprocessed"

mapper <- "data_mapping_template.csv"
```

# **Part 1: Gifts Data**

##**Import**

Two methodologies. One for when there is a single file. And the other for multiple files.

###Single Gift File
```{r}
file_name <- "gifts_file.csv"
file <- file.path(file_path, clients, subdir, file_name)
df_gift <- read_csv(file, name_repair = make_clean_names) 

#if weird encoding
#read.csv( file,encoding="ISO-8859-1")
```

###Multiple gift files

*You have to first place all gift files in a new folder of the Raw Client Folder and name it Section 2*
  ```{r}
file_folder<- "Section 2" #gift file folder

file_paths_gifts <-fs::dir_ls(paste(file_path, clients, subdir, file_folder,sep = "\\"))

#Then it will read the folder location to find out all the files in the folder. It will attach to the file type and read it in. As it reads it in, it converts everything to snake case.
filecontents_g<- file_paths_gifts %>%
  map(function (path) {
    
    filetype<- stri_extract_last(basename(path),regex = "\\.+[:alpha:]{3,4}")
    
    if(filetype %in% c(".xlsx",".xls")){
      read_xlsx(path, .name_repair = make_clean_names)
    }
    else if(filetype %in% c(".csv",".txt",".CSV")){
      read_csv(path, name_repair = make_clean_names)
    }
    else{
      print("File type something else")
    }
  })

filecontents_g<- set_names(filecontents_g, stri_replace_all(basename(file_paths_gifts),fixed = " ",replacement = "_"))
```

#**Explore the gift data**

##What are the columns? 

Check across the list of data frames to see if names are the same. Only applicable for multiple files.

*If there is no difference in the list or if there is only one file, then you can proceed to the next step.*
  ```{r}
ls_intersection(filecontents_g)
```

check column names
```{r}
colnames(filecontents_g[[1]])
```

##Multifiles Only: What are the Data Types

Check the list of Dataframes for different Data Types 

Only applicable for list of dataframes. This step is so you know what types you need to change
```{r}
compare_datatypes(filecontents_g)
```

##View structure of gift data
```{r}
str(filecontents_g[[1]])
```

OR

```{r}
str(df_gift)
```

##Multifiles Only: Combine Gift files

If applicable data processing step. If filecontents_g does not exist then there is nothing to do.
```{r add file name column}
filecontents_g<- filecontents_g %>%
  map2(names(filecontents_g),
       ~ mutate(.x, file_name = .y))
```

```{r combine files}
df_gift<- map_dfr(filecontents_g, ~{
  .x %>%
    mutate(gift_date = as.Date(gift_date, format = "%m/%d/%Y"),
           gift_amount = as.numeric(remove_dollar_sign_and_comma(gift_amount)),
           is_individual = if_else(constituent_code== "Individual", 1, 0)) %>% 
    relocate(file_name,.after = last_col())
})
```

# Gift Data Check

##get normal stats.
```{r}
max(df_gift$gift_date)
min(df_gift$gift_date)
max(df_gift$gift_amount)
n_distinct(df_gift$constituent_id)
unique(df_gift$constituent_code)
```

##Check for Duplicates

Check and write a file to show the duplicate gifts.
```{r Checking Dups, warning=FALSE}
df_dups<- df_gift %>% 
  group_by(constituent_id, gift_date) %>%
  filter(n()>1,)

# write.csv(df_dups,"Gifts_Duplicates_v1.csv", row.names = FALSE)
```

So we have duplicates based on that but they have different gift_funds and gift ids. So we will keep.

##Check and export gift types

```{r Gift Type Identification}
gift_type<- data.frame(unique(df_gift$gift_type))
```

##**Save the gift file**

```{r}
save_file(df_gift,file_prefix = save_gifts_after_mapping, version = "v1")
```

#remove gift stuff
```{r}
rm(list = ls(pattern = "filecontents_g|df_gift|df_dups|gift_type"))
```

# *Constituents Data*

##Import Data

###Single Constituent File
```{r}
file_name <- "constituents_file.csv"
file <- file.path(file_path, clients, subdir, file_name)
df_const<-read_csv(file, name_repair = make_clean_names)

#if weird encoding
#df_const <- read.csv(file, encoding="ISO-8859-1")
```

###Multiple Constituent Files

*You have to first place all constituent files in a new folder of the Raw Client Folder and name it Section 3*
  
  ```{r}
file_folder<- "Section 3" #constituent files folder

file_paths_consts <-fs::dir_ls(paste(file_path, clients, subdir, file_folder,sep = "\\"))

#Then it will read the folder location to find out all the files in the folder. It will attach to the file type and read it in. As it reads it in, it converts everything to snake case.
filecontents_c<- file_paths_consts %>%
  map(function (path) {
    
    filetype<- stri_extract_last(basename(path),regex = "\\.+[:alpha:]{3,4}")
    
    if(filetype %in% c(".xlsx",".xls")){
      read_xlsx(path, .name_repair = make_clean_names)
    }
    else if(filetype %in% c(".csv",".txt",".CSV")){
      read_csv(path, name_repair = make_clean_names)
    }
    else{
      print("File type something else")
    }
  })

filecontents_c<- set_names(filecontents_c, stri_replace_all(basename(file_paths_consts),fixed = " ",replacement = "_"))
```

#**Explore the Constituent data**

##What are the columns? 

Check across the list of dataframes to see if names are the same. Only applicable for multiple files.
```{r}
ls_intersection(filecontents_c)
```

##What is the data?

Take a look at the first 10 rows of each column in the dataframes.

```{r}
#for multiple files
for(i in 1:length(filecontents_c)){
  print(head(filecontents_c[[i]]))
}

#for single file
print(head(df_const))
```

#Rename Columns

If necessary to rename

```{r}
filecontents_c[[1]]<- filecontents_c[[1]] %>% rename(constituent_code = constituent_codes,
                                                     spouse_name = spouse_2)

```

##Multifiles Only: What are the Data Types
Check the dataframes column data types to see if different.

```{r}
compare_datatypes(filecontents_c)
```

##View structure of constituent data

```{r}
str(filecontents_c[[1]])
```

OR

```{r}
str(df_const)
```

##Multifiles Only: Combine files
No differences so will initialize combinations
```{r add file name column}
filecontents_c<- filecontents_c %>%
  map2(names(filecontents_c),
       ~ mutate(.x, file_name = .y))
```

```{r combine files}
df_const<- map_dfr(filecontents_c, ~{
  .x %>%
    mutate(birth_date = as.Date(birth_date, format = "%m/%d/%Y"),
           first_gift_date = as.Date(first_gift_date, format = "%m/%d/%Y"),
           last_gift_date = as.Date(last_gift_date, format = "%m/%d/%Y"),
           is_individual = if_else(constituent_code== "Individual", 1, 0)) %>% 
    relocate(file_name,.after = last_col())
})
```

# Formatting

#Adding in cleaned zip codes

```{r}
df_cd<-
  df_cd %>%
  mutate(zip_clean = check_zip(df_const,))
```

**Remove dollar sign and comma**
  
  ```{r}
df_const<- df_const %>%
  mutate(across(.cols = where(~any((grepl(pattern = "\\$|\\£|\\€", x = .) & !grepl(pattern = "[A-Za-z]+", x = .)))),
                #mutate(across(.cols = c("insert_col_names"), #version that you can specify fields yourself
                .fns = ~remove_dollar_sign_and_comma(.x)
  ))
```

OR

```{r}
# Remove dollar sign and comma
#df_const <- df_const %>% mutate(across(everything(), remove_dollar_sign_and_comma))

# Convert giving columns to numeric
givings_columns <- grep("giving|gift", tolower(names(df_const)), value = TRUE)
df_const <- df_const %>% mutate(across(all_of(givings_columns), remove_dollar_sign_and_comma)) %>% mutate(across(all_of(givings_columns), as.numeric)) %>% 
  replace_na(list(givings_columns = 0))
```

## is_deceased

```{r}
df_const <- df_const %>% mutate(is_deceased = ifelse(deceased == "Yes", 1, 0))
```

## is_assigned

Can't find this info so 0

```{r}
df_const <- df_const %>% mutate(is_assigned = 0)
```

## assigned_manager

Can't find this info so 0

```{r}
df_const <- df_const %>% mutate(assigned_manager = 0)
```

## loyalty_model_score, major_donor_model_score n_years_of_giving_of_ten

```{r}
df_const<- df_const %>% 
  mutate(major_donor_model_score = 0,
         loyalty_model_score = 0,
         n_years_giving_of_ten = NA)
```

#Create Giving information if not in constituent file

##YoY Giving

Pull in new gift file
```{r}
df_gift<-read.csv("~\\gifts_preprocessed_v1.csv")
```

create YoY stuff
```{r}
df_gift<- df_gift %>% 
  mutate(FY = if_else(month(ccs_date) < 7, year(ccs_date), year(ccs_date) + 1))

df_gift_amt<- df_gift %>% 
  group_by(constituent_id, FY) %>%
  summarise(total_gift_amt = sum(amount, na.rm = TRUE))

df_gift_amt_2025<- df_gift_amt %>% 
  filter(FY == 2025)

df_gift_amt_2024<- df_gift_amt %>% 
  filter(FY == 2024)

df_gift_amt_2023<- df_gift_amt %>% 
  filter(FY == 2023)

df_gift_amt_2022<- df_gift_amt %>% 
  filter(FY == 2022)

df_gift_amt_2021<- df_gift_amt %>% 
  filter(FY == 2021)

df_gift_amt_2020<- df_gift_amt %>%
  filter(FY ==2020)

df_gift_amt_2019<- df_gift_amt %>%
  filter(FY == 2019)

df_gift_amt_2018<- df_gift_amt %>%
  filter(FY == 2018)

df_gift_amt_2017<- df_gift_amt %>%
  filter(FY == 2017)

df_gift_amt_2016<- df_gift_amt %>%
  filter(FY == 2016)

df_gift_amt_2015<- df_gift_amt %>%
  filter(FY == 2015)

df_gift_amt_2014<- df_gift_amt %>%
  filter(FY == 2014)

df_const<- df_const %>%
  left_join(df_gift_amt_2025 %>% select(constituent_id, total_gift_amt) %>% rename(CCS_FY25_giving = total_gift_amt), by = "constituent_id") %>%
  left_join(df_gift_amt_2024 %>% select(constituent_id, total_gift_amt) %>% rename(CCS_FY24_giving = total_gift_amt), by = "constituent_id") %>%
  left_join(df_gift_I_amt_2023 %>% select(contact_number_contact_contact, total_gift_amt) %>% rename(CCS_FY23_giving = total_gift_amt), by = "contact_number_contact_contact") %>%
  left_join(df_gift_I_amt_2022 %>% select(contact_number_contact_contact, total_gift_amt) %>% rename(CCS_FY22_giving = total_gift_amt), by = "contact_number_contact_contact") %>%
  left_join(df_gift_I_amt_2021 %>% select(contact_number_contact_contact, total_gift_amt) %>% rename(CCS_FY21_giving = total_gift_amt), by = "contact_number_contact_contact") %>%
  left_join(df_gift_I_amt_2020 %>% select(contact_number_contact_contact, total_gift_amt) %>% rename(CCS_FY20_giving = total_gift_amt), by = "contact_number_contact_contact") %>%
  left_join(df_gift_I_amt_2019 %>% select(contact_number_contact_contact, total_gift_amt) %>% rename(CCS_FY19_giving = total_gift_amt), by = "contact_number_contact_contact") %>% 
  left_join(df_gift_I_amt_2018 %>% select(contact_number_contact_contact, total_gift_amt) %>% rename(CCS_FY18_giving = total_gift_amt), by = "contact_number_contact_contact") %>%
  left_join(df_gift_I_amt_2017 %>% select(contact_number_contact_contact, total_gift_amt) %>% rename(CCS_FY17_giving = total_gift_amt), by = "contact_number_contact_contact") %>%
  left_join(df_gift_I_amt_2016 %>% select(contact_number_contact_contact, total_gift_amt) %>% rename(CCS_FY16_giving = total_gift_amt), by = "contact_number_contact_contact") %>%
  left_join(df_gift_I_amt_2015 %>% select(contact_number_contact_contact, total_gift_amt) %>% rename(CCS_FY15_giving = total_gift_amt), by = "contact_number_contact_contact") %>%
  left_join(df_gift_I_amt_2014 %>% select(contact_number_contact_contact, total_gift_amt) %>% rename(CCS_FY14_giving = total_gift_amt), by = "contact_number_contact_contact")

#Changing NAs of the FY giving fields to zero so stuff can be summed
df_const<- df_const %>% 
  mutate(across(.cols = c(CCS_FY25_giving:CCS_FY14_giving),
                .fns = ~if_else(is.na(.x), 0, .x)))

df_const$five_year_giving <- rowSums(df_const[, c("CCS_FY24_giving", "CCS_FY23_giving", "CCS_FY22_giving", "CCS_FY21_giving","CCS_FY20_giving")])

```

##Make First and Last year gift date and gift amounts
If necessary
```{r}
#find the date of the first gift from gift file. Same with last gift date

#finding first gift date and last gift date
df_gift_first<-df_gift %>% 
  group_by(constituent_id) %>%
  summarise(first_gift_date = min(ccs_date)) %>% 
  ungroup()

df_gift_last<-df_gift %>% 
  group_by(constituent_id) %>%
  summarise(last_gift_date = max(ccs_date)) %>% 
  ungroup()

#join together both the first and last gift dates
df_const<-df_const %>% 
  left_join(df_gift_first, by = constituent_id) %>%
  left_join(df_gift_last, by = c("constituent_id" = "constituent_id"))

#Lets bring in the amounts for these times

df_gift_first_amt<-df_gift %>% 
  group_by(constituent_id,ccs_date) %>%
  summarise(first_gift_amt = sum(amount) ) %>% 
  ungroup()

df_gift_last_amt<-df_gift %>% 
  group_by(constituent_id,ccs_date) %>%
  summarise(last_gift_amt = sum(amount)) %>% 
  ungroup()

#find the corresponding amount by joining in the amount field on date and contact_number_contact_contact field
df_const<-df_const %>% 
  left_join(df_gift_first_amt, by = c(constituent_id, "first_gift_date.y" = "ccs_date")) %>%
  left_join(df_gift_last_amt, by = c("constituent_id" = "constituent_id", "last_gift_date" = "ccs_date"))
```

##Figuring out the number of gifts.

If necessary
```{r}
df_cd_ngifts<-df_gift %>% 
  group_by(constituent_id) %>%
  summarise(total_number_of_gifts = n())

df_const<-df_const %>% 
  left_join(df_cd_ngifts, by = c("constituent_id" = "constituent_id"))
```

##Figuring out the largest gift.

If necessary
```{r}
df_cd_largest_gift<-df_gift %>% 
  group_by(contact_number_contact_contact) %>%
  summarise(largest_gift_amt = max(amount))

df_const<-df_const %>%
  left_join(df_cd_largest_gift, by = c("contact_number_contact_contact" = "contact_number_contact_contact"))
```


##Make n_years_of_giving_of_ten

```{r}
df_const<- df_const %>% 
  mutate(n_years_giving_of_ten = NA)
```

<!-- # ```{r} -->
  <!-- #  #count the number of non-NA values across giving columns to derive n_years_giving -->
  <!-- #  df_cd<-df_cd %>%  -->
  <!-- #   mutate(n_years_giving = rowSums(across(c(CCS_FY24_giving:CCS_FY15_giving))>0)) -->
  <!-- # ``` -->
  
  <!-- n_years_giving_of_ten creation.. 2 ways dependent on if there is 10 years in the constituent file -->
  
  <!-- If there is 10 years in the const file: -->
  <!-- ```{r} -->
  <!-- df_const<- rowSums() -->
  <!-- ``` -->
  
  <!-- If there is not 10 years in const file pull from gift file: -->
  <!-- ```{r} -->
  <!-- df_gift<-read.csv("gifts_preprocessed_v1.csv") -->
  <!-- #look for a single gift each year within the last ten years -->
  <!-- df_gift_n_years_of_ten<- df_gift %>%  -->
  <!--   mutate(FY = if_else(month(gift_date) < 7, year(gift_date), year(gift_date) + 1)) %>%  -->
  <!--   filter(gift_date >= max(gift_date) - years (10)) %>%  -->
  <!--   group_by(constituent_id, FY) %>%  -->
  
  <!-- ``` -->
  
  **Save file for DV creation**
  
  This is the file that will be used to create DV report
```{r}
save_file(df_const, save_constit_for_dv, "v1")
```

## head_of_household and household_id

```{r}
# Function to determine index of row with max "Total Lifetime Giving" or default to first row
get_max_index <- function(group) {
  if ("Total Lifetime Giving" %in% names(group)) {
    if (max(group$`Total Lifetime Giving`, na.rm = TRUE) > 0) {
      return(which.max(group$`Total Lifetime Giving`))
    }
  }
  return(1)
}
```

```{r}
df_cdi <- df_cd %>% filter(!is_deceased & is_individual) %>% mutate(head_of_household = TRUE)
```

```{r}
# Drop rows where both Addr1 and Addr2 are NaN
df_cdi <- df_cdi %>% drop_na(Address_1, Address_2, how = "all")

# Fill NaNs with a placeholder value (e.g., 'missing')
df_cdi <- df_cdi %>% replace_na(list(Address_1 = "missing", Address_2 = "missing", City = "missing", State = "missing", Zip = "missing"))

# Filter rows to ensure there's something numeric in at least one of Addr1 or Addr2
df_cdi <- df_cdi %>% filter(apply(df_cdi, 1, function(row) roman_or_numeral(row["Address_1"]) | roman_or_numeral(row["Address_2"])))

df_cdi_multiple <- df_cdi %>% group_by(Address_1, Address_2, City, State, Zip) %>% filter(n() > 1) %>% arrange(Address_1, Address_2, City, State, Zip)

# Identify index of rows with max "Total Lifetime Giving" or default to first row
idx_max_lifetime_giving <- df_cdi_multiple %>% group_by(Address_1, Address_2, City, State, Zip) %>% summarize(idx = get_max_index(cur_data()), .groups = "drop")

# Set "head_of_household" to False for all entries in subgroups with multiple entries
df_cdi <- df_cdi %>% mutate(head_of_household = ifelse(row_number() %in% idx_max_lifetime_giving$idx, TRUE, FALSE))

# Assign unique household_id to each subgroup
df_cdi_multiple <- df_cdi_multiple %>% group_by(Address_1, Address_2, City, State, Zip) %>% mutate(household_id = row_number())

# Merge the household_id back into the original df_cdi
df_cdi <- df_cdi %>% left_join(df_cdi_multiple %>% select(Unique_Donor_ID, household_id), by = "Unique Donor ID") %>% replace_na(list(household_id = 0))

# Merge the head_of_household and household_id into df_cd
df_cd <- df_cd %>% left_join(df_cdi %>% select(Unique_Donor_ID, head_of_household, household_id), by = "Unique Donor ID")
```

## solicit_codes

```{r}
if ("solicit_codes" %in% names(df_cd)) {
  df_cd <- df_cd %>% select(-solicit_codes)
}
columns_solicit_codes <- grep("solicit", tolower(names(df_cd)), value = TRUE)
df_cd <- df_cd %>% mutate(solicit_codes = rowSums(!is.na(select(df_cd, all_of(columns_solicit_codes)))) > 0)
df_cd$solicit_codes <- as.integer(df_cd$solicit_codes)
```

## marital_status

```{r}
columns_spouse <- grep("spouse", tolower(names(df_cd)), value = TRUE, invert = TRUE)
df_cd <- df_cd %>% mutate(marital_status = ifelse(rowSums(!is.na(select(df_cd, all_of(columns_spouse)))) > 0, "married", NA))
df_cd <- df_cd %>% mutate(marital_status = ifelse(`Spouse deceased`, "widow", marital_status))
```


## planned_gift_commitment

```{r}
columns_planned <- grep("planned", tolower(names(df_cd)), value = TRUE)
df_cd <- df_cd %>% mutate(planned_gift_commitment = ifelse(rowSums(!is.na(select(df_cd, all_of(columns_planned)))) > 0, 1, 0))
```

## Address

```{r}
df_cd <- df_cd %>% mutate(business_address = preferred_address_type == "Business")
df_cd <- df_cd %>% mutate(seasonal_address = grepl("summer|winter|alternate", preferred_address_type, ignore.case = TRUE))
```

## Phone

```{r}
df_cd <- df_cd %>% mutate(home_phone = ifelse(`Phone Type` == "Home", `Phone Number`, NA))
df_cd <- df_cd %>% mutate(home_phone = ifelse((`Phone Type_1` == "Home") & is.na(home_phone), `Phone Number_1`, home_phone))

df_cd <- df_cd %>% mutate(cell_phone = ifelse(`Phone Type` == "Cell", `Phone Number`, NA))
df_cd <- df_cd %>% mutate(cell_phone = ifelse((`Phone Type_1` == "Cell") & is.na(cell_phone), `Phone Number_1`, cell_phone))
```

## Email

```{r}
df_cd <- df_cd %>% mutate(personal_email = coalesce(`Email`, `Email_1`, `Email_2`, `Email_3`))
```

## number_of_events_attended

```{r}
df_cd <- df_cd %>% mutate(number_of_special_events_attended = rowSums(!is.na(select(df_cd, Events:Events_5))))
```

## total_notes

```{r}
df_cd <- df_cd %>% mutate(Total_Notes = coalesce(`Total_Notes`, 0))
df_cd <- df_cd %>% mutate(`Total Notes` = coalesce(`Total Notes`, 0))
df_cd <- df_cd %>% mutate(total_notes = `Total_Notes` + `Total Notes`)
```

## Loyalty

```{r}
columns_yearly_giving <- c("2023 Total Giving", "2022 Total Giving", "2021 Total Giving", "2020 Total Giving", "2019 Total Giving", "2018 Total Giving", "2017 Total Giving", "2016 Total Giving", "2015 Total Giving", "2014 Total Giving")
```


```{r}
# Function to determine the first year a gift was made
first_gift_year <- function(row) {
  first_gift_year <- NA
  for (i in seq_along(columns_yearly_giving)) {
    if (row[[columns_yearly_giving[i]]] > 0) {
      first_gift_year <- current_year - i
      break
    }
  }
  return(first_gift_year)
}

# Function to calculate the number of years gifts were made
years_gifts_made <- function(row) {
  return(sum(row[columns_yearly_giving] > 0))
}

# Function to calculate loyalty
calculate_loyalty <- function(row) {
  if (!is.na(row[["first_gift_year"]])) {
    return(row[["number_of_years_gifts_were_made"]] / (current_year - row[["first_gift_year"]]))
  }
  return(0)
}
```

```{r}
# Get the current year
current_year <- year(Sys.Date())

df_cd <- df_cd %>% rowwise() %>% mutate(first_gift_year = first_gift_year(cur_data()), number_of_years_gifts_were_made = years_gifts_made(cur_data()), loyalty = calculate_loyalty(cur_data()))
```

**Save file before applying mapper**
  
  ```{r}
save_file(df_cd, save_constit_before_mapping, "v1")
```

# Mapper

**ADD A CHECK TO ENSURE NO FIELDS ARE DUPLICATED**
  
  ```{r}
mapping <- read_csv(mapper)
column_mapping <- mapping %>% filter(file_columns != "not_found") %>% select(file_columns, expected_columns) %>% deframe()
df_final <- df_cd %>% rename(!!!column_mapping)
df_final <- df_final %>% select(all_of(column_mapping))
```

## Datatypes

### Age

```{r}
# Convert age column to datetime
df_final <- df_final %>% mutate(age = as_date(convert_to_datetime(age)))
```

## Save the final preprocessed-file

```{r}
save_file(df_final, save_constit_after_mapping, "v1")
```

### Correlation Plots with Total Lifetime Giving

```{r}
library(ggplot2)

# Drop rows with NaNs in these columns
df_cleaned <- df_cdi_multiple %>% drop_na(`Total Lifetime Giving`, `Total Actions`)

ggplot(df_cleaned, aes(x = log(`Total Lifetime Giving`), y = `Total Actions`)) +
  geom_point() +
  labs(title = "Scatter Plot of Total Lifetime Giving vs. Total Actions",
       x = "Total Lifetime Giving (log scale)",
       y = "Total Actions") +
  theme_minimal()

df_cleaned <- df_cdi_multiple %>% drop_na(`Total Lifetime Giving`, `Pledged Planned Gift`)

ggplot(df_cleaned, aes(x = log(`Total Lifetime Giving`), y = `Pledged Planned Gift`)) +
  geom_point() +
  labs(title = "Scatter Plot of Total Lifetime Giving vs. Pledged Planned Gift",
       x = "Total Lifetime Giving (log scale)",
       y = "Pledged Planned Gift") +
  theme_minimal()
```